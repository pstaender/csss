// Generated by CoffeeScript 1.6.2
var CSSS, DocumentStyle, MyEnvironment, exports, _ref;

if (typeof CoffeeScript === "undefined" || CoffeeScript === null) {
  throw 'CoffeeScript is needed';
}

DocumentStyle = (function() {
  function DocumentStyle() {}

  DocumentStyle.prototype._import = [];

  DocumentStyle.prototype._tree = {};

  DocumentStyle.prototype._levels = [];

  DocumentStyle.prototype["eval"] = null;

  DocumentStyle.prototype._environments = {};

  DocumentStyle.prototype.begin = '# csss definition starts here';

  DocumentStyle.prototype.init = function() {
    return this._levels = [];
  };

  DocumentStyle.prototype._extend = function(obj) {
    var each, has;

    has = function(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    each = function(obj, iterator, context) {
      var i, key, l;

      if (obj == null) {
        return;
      }
      if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {
        return obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        i = 0;
        l = obj.length;
        while (i < l) {
          if (iterator.call(context, obj[i], i, obj) === breaker) {
            return;
          }
          i++;
        }
      } else {
        for (key in obj) {
          if (_.has(obj, key) ? iterator.call(context, obj[key], key, obj) === breaker : void 0) {
            return;
          }
        }
      }
    };
    each(Array.prototype.slice.call(arguments, 1), function(source) {
      var prop, _results;

      if (source) {
        _results = [];
        for (prop in source) {
          _results.push(obj[prop] = source[prop]);
        }
        return _results;
      }
    });
    return obj;
  };

  DocumentStyle.prototype["import"] = function(file) {
    return this._import.push(file);
  };

  DocumentStyle.prototype.use = function(yourClassName) {
    var yourClass;

    yourClass = this._environments[yourClassName];
    if (yourClass && typeof yourClass === 'function') {
      return DocumentStyle.prototype._extend(this, new yourClass);
    } else {
      throw new Error("Couldn't find/use '" + yourClassName + "'");
    }
  };

  DocumentStyle.prototype.add = function() {
    var args;

    args = Array.prototype.slice.call(arguments);
    return this._levels.push(args);
  };

  DocumentStyle.prototype.addEnvironment = function(yourClass) {
    var className, _ref, _ref1;

    if (typeof yourClass === 'function') {
      className = (_ref = yourClass.toString()) != null ? (_ref1 = _ref.split('\n')) != null ? _ref1[0].replace(/^function\s(.+?)\(.*/, '$1') : void 0 : void 0;
      return this._environments[className] = yourClass;
    }
  };

  DocumentStyle.prototype.media = function(query) {
    return this.add('@media', query);
  };

  return DocumentStyle;

})();

MyEnvironment = (function() {
  function MyEnvironment() {}

  MyEnvironment.prototype.myPadding = function() {
    return 12 + 'px';
  };

  return MyEnvironment;

})();

DocumentStyle.prototype.addEnvironment(MyEnvironment);

CSSS = (function() {
  CSSS.prototype.original = null;

  CSSS.prototype.source = null;

  CSSS.prototype.styletext = null;

  CSSS.prototype.coffeescript = null;

  CSSS.prototype.javascript = null;

  CSSS.prototype.context = null;

  CSSS.prototype.evaluated = null;

  CSSS.prototype.tree = {};

  CSSS.prototype.declarationPart = null;

  CSSS.prototype.seperateDeclarations = true;

  CSSS.prototype.attributesTypes = 'animation|animation-name|animation-duration|animation-timing-function|animation-delay|animation-iteration-count|animation-direction|animation-play-state|background|background-attachment|background-color|background-image|background-position|background-repeat|background-clip|background-origin|background-size|border|border-bottom|border-bottom-color|border-bottom-style|border-bottom-width|border-color|border-left|border-left-color|border-left-style|border-left-width|border-right|border-right-color|border-right-style|border-right-width|border-style|border-top|border-top-color|border-top-style|border-top-width|border-width|outline|outline-color|outline-style|outline-width|border-bottom-left-radius|border-bottom-right-radius|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-radius|border-top-left-radius|border-top-right-radius|box-decoration-break|box-shadow|overflow-x|overflow-y|overflow-style|rotation|rotation-point|color-profile|opacity|rendering-intent|bookmark-label|bookmark-level|bookmark-target|float-offset|hyphenate-after|hyphenate-before|hyphenate-character|hyphenate-lines|hyphenate-resource|hyphens|image-resolution|marks|string-set|height|max-height|max-width|min-height|min-width|width|box-align|box-direction|box-flex|box-flex-group|box-lines|box-ordinal-group|box-orient|box-pack|font|font-family|font-size|font-style|font-variant|font-weight|@font-face|font-size-adjust|font-stretch|content|counter-increment|counter-reset|quotes|crop|move-to|page-policy|grid-columns|grid-rows|target|target-name|target-new|target-position|alignment-adjust|alignment-baseline|baseline-shift|dominant-baseline|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust|drop-initial-before-align|drop-initial-size|drop-initial-value|inline-box-align|line-stacking|line-stacking-ruby|line-stacking-shift|line-stacking-strategy|text-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|marquee-direction|marquee-play-count|marquee-speed|marquee-style|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|padding|padding-bottom|padding-left|padding-right|padding-top|fit|fit-position|image-orientation|page|size|bottom|clear|clip|cursor|display|float|left|overflow|position|right|top|visibility|z-index|orphans|page-break-after|page-break-before|page-break-inside|widows|ruby-align|ruby-overhang|ruby-position|ruby-span|mark|mark-after|mark-before|phonemes|rest|rest-after|rest-before|voice-balance|voice-duration|voice-pitch|voice-pitch-range|voice-rate|voice-stress|voice-volume|border-collapse|border-spacing|caption-side|empty-cells|table-layout|color|direction|letter-spacing|line-height|text-align|text-decoration|text-indent|text-transform|unicode-bidi|vertical-align|white-space|word-spacing|hanging-punctuation|punctuation-trim|text-align-last|text-justify|text-outline|text-overflow|text-shadow|text-wrap|word-break|word-wrap|2transform|transform-origin|transform-style|perspective|perspective-origin|backface-visibility|transition|transition-property|transition-duration|transition-timing-function|transition-delay|appearance|box-sizing|icon|nav-down|nav-index|nav-left|nav-right|nav-up|outline-offset|resize';

  CSSS.prototype.pattern = {
    isInlineOperation: /\s+([a-zA-Z0-9\(]+[\(\)\%\/\*\+\-\.\s]*)+\s*$/,
    detectUnit: /[0-9]+(\.[0-9]+)*(in\b|cm\b|mm\b|em\b|ex\b|pt\b|pc\b|px\b|s\b|\%)/,
    isLineSelector: /^[a-z\.\#\&]+[a-z0-9\,\s\#\*\:\>\[\]\=\~\+\.\(\)\-\"\']*$/i,
    isLineAttribute: /^(\s+)([a-zA-Z\-]+)(\:|\s){1}/,
    comments: function() {
      return /(#\s.*|\/\/.*)?\n/g;
    },
    isMediaQuery: /^(\@media)\s+(.*)$/,
    isCSSValue: /^([0-9\.]+(in|cm|mm|em|ex|pt|pc|px|s|\%))$/,
    hasOperator: function() {
      return /\s[\+\-\/\*\%]{1}\s/g;
    },
    isNotParsableValue: /^([0-9]+(\.[0-9])*|\@*[a-zA-Z\_]+)$/,
    doesLineBeginWithAttribute: null,
    processPartsSeperator: /\n@begin\n/,
    cssColorValues: function() {
      return /\s(\#[a-z0-9]{3,6}|AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGray|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|Darkorange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGray|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGray|DimGrey|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gray|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGray|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGray|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGray|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\s*/ig;
    },
    variableWithUnit: function() {
      return /^(\@[a-zA-Z\_]+)\[(in|cm|mm|em|ex|pt|pc|px|s|\%)\]/g;
    }
  };

  function CSSS(original) {
    this.original = original != null ? original : null;
  }

  CSSS.prototype.createContext = function() {
    return this.context = new DocumentStyle();
  };

  CSSS.prototype.transformCssObjectsToJSON = function(s, options) {
    var css, currentWhiteSpacesCount, i, l, line, lineBeginsWithAttribute, lines, parsed, replace, whiteSpaces, whiteSpacesCount, _i, _len, _ref, _ref1;

    if (options == null) {
      options = {};
    }
    replace = options.replace;
    if (replace == null) {
      replace = true;
    }
    css = [];
    whiteSpacesCount = null;
    lines = s.split('\n');
    whiteSpaces = null;
    currentWhiteSpacesCount = null;
    for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
      line = lines[i];
      if (whiteSpaces == null) {
        whiteSpaces = (_ref = line.match(/^(\s+)/)) != null ? _ref[1] : void 0;
      }
      if (currentWhiteSpacesCount == null) {
        currentWhiteSpacesCount = (whiteSpaces != null ? whiteSpaces.length : void 0) || null;
      }
      lineBeginsWithAttribute = this.doesLineBeginsWithAttribute(line);
      if (currentWhiteSpacesCount > 0) {
        if (whiteSpacesCount !== currentWhiteSpacesCount || lineBeginsWithAttribute !== true) {
          css = [];
          if (whiteSpacesCount == null) {
            whiteSpacesCount = currentWhiteSpacesCount;
          }
          whiteSpaces = null;
        }
        if (lineBeginsWithAttribute) {
          if (whiteSpaces == null) {
            whiteSpaces = ((_ref1 = line.match(/^(\s+)/)) != null ? _ref1[1] : void 0) || '';
          }
          if (css.length === 0) {
            l = whiteSpaces + "o =\n";
            whiteSpaces += '  ';
            whiteSpacesCount = currentWhiteSpacesCount = whiteSpacesCount + 2;
            lines[i] = l + this.parseAttributeLine(line, {
              indent: whiteSpaces,
              escape: true
            });
            css.push(parsed);
          } else {
            whiteSpacesCount = currentWhiteSpacesCount;
            parsed = this.parseAttributeLine(line, {
              indent: whiteSpaces,
              escape: true
            });
            if (replace) {
              lines[i] = parsed;
            }
            if (lineBeginsWithAttribute) {
              css.push(parsed);
            }
          }
        }
      }
    }
    if (replace) {
      return lines.join('\n');
    } else {
      return css;
    }
  };

  CSSS.prototype.escapeCSSValue = function(s) {
    return s != null ? s.replace(/\'/g, "\\'") : void 0;
  };

  CSSS.prototype.operateInline = function(s, options) {
    var enclose, escape, hasOperators, onlyIfOperatorsExists, unit, _ref;

    if (options == null) {
      options = {};
    }
    onlyIfOperatorsExists = options.onlyIfOperatorsExists, enclose = options.enclose, escape = options.escape;
    if (escape == null) {
      escape = false;
    }
    if (s) {
      s = String(s).trim(s);
      if (/^[0-9]+(\.[0-9]+)*$/.test(s) || /^\s*(@[a-zA-Z\_]+(\(.*?\))*\s*)+$/.test(s)) {
        if (enclose == null) {
          enclose = false;
        }
      }
      if (enclose == null) {
        enclose = true;
      }
      if (this.pattern.isCSSValue.test(s)) {
        if (onlyIfOperatorsExists == null) {
          onlyIfOperatorsExists = false;
        }
      }
      if (onlyIfOperatorsExists == null) {
        onlyIfOperatorsExists = true;
      }
      hasOperators = this.pattern.hasOperator().test(s);
      if (this.pattern.variableWithUnit().test(s)) {
        escape = enclose = false;
        s = s.replace(this.pattern.variableWithUnit(), "$1 + '$2'");
      }
      if (!hasOperators && /(@[a-zA-Z\_]+(\(.*?\)))/.test(s)) {
        if (enclose == null) {
          enclose = true;
        }
        if (enclose) {
          if (escape) {
            s = this.escapeCSSValue(s);
          }
          s = "'" + s + "'";
          return s.replace(/(@[a-zA-Z\_]+)(\(.*?\))/g, " ' + $1$2 + ' ");
        }
      }
      if (onlyIfOperatorsExists && !hasOperators) {
        if (escape) {
          s = this.escapeCSSValue(s);
        }
        if (enclose) {
          return "'" + (s.replace(/(\s@[a-zA-Z]+)(\(.*?\))*\s/g, " ' + $1$2 + ' ")) + "'";
        } else {
          return "" + s;
        }
      }
      if (/^(\'.*\'|\".*\")$/.test(s)) {
        return s;
      }
      unit = ((_ref = s.match(this.pattern.detectUnit)) != null ? _ref[2] : void 0) || null;
      if (unit) {
        s = "( " + (s.split(unit).join('')) + " + '" + unit + "' )";
      } else {
        s = "( " + (s.split(unit).join('')) + " )";
      }
    } else {
      s = '';
    }
    return s;
  };

  CSSS.prototype.seperateDeclarationAndStyle = function() {
    var declarationPart, declarationsEnds, found, line, setBeginIfNotFound, splitPattern, styletext, useMediaQueryAsSeperator, _i, _len, _ref, _ref1;

    this.source = '';
    this.declarationPart = '';
    styletext = '';
    declarationPart = '';
    setBeginIfNotFound = '@begin';
    this.original = '\n' + this.original;
    useMediaQueryAsSeperator = true;
    splitPattern = this.pattern.processPartsSeperator;
    found = this.original.match(splitPattern);
    if (!found && useMediaQueryAsSeperator) {
      this.original = this.original.replace(/\n@media\s/, "\n" + setBeginIfNotFound + "\n@media ");
      found = this.original.match(splitPattern);
    }
    if (found) {
      _ref = this.original.split(splitPattern), declarationPart = _ref[0], styletext = _ref[1];
      styletext = ("\n" + found[0] + "\n") + styletext;
    } else {
      declarationsEnds = null;
      _ref1 = this.original.split('\n');
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        line = _ref1[_i];
        if (this.pattern.isLineSelector.test(line) || this.pattern.isMediaQuery) {
          declarationsEnds = true;
        }
        if (!declarationsEnds) {
          declarationPart += '\n' + line;
        } else {
          styletext += '\n' + line;
        }
      }
    }
    this.styletext = styletext;
    return this.declarationPart = declarationPart;
  };

  CSSS.prototype.processDeclaration = function() {
    var declarationPart, i, line, parts;

    this.declarationPart = this.transformCssObjectsToJSON(this.declarationPart, {
      replace: true
    });
    declarationPart = (function() {
      var _i, _len, _ref, _ref1, _results;

      _ref = this.declarationPart.split('\n');
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        line = _ref[i];
        if (!/(\'.*\')|(\".*\")/.test(line)) {
          line = line.replace(this.pattern.cssColorValues(), " '$1' ");
        }
        if (this.pattern.isInlineOperation.test(line)) {
          parts = line.match(/^(\s*)(.*?\=\s*)(.*)$/, line);
          if (parts != null ? parts[3] : void 0) {
            line = parts[1] + parts[2] + this.operateInline(parts[3], {
              enclose: false
            });
          } else {
            line = ((_ref1 = line.match(/^\s*/)) != null ? _ref1[0] : void 0) + this.operateInline(line, {
              enclose: false
            });
          }
        }
        _results.push(line);
      }
      return _results;
    }).call(this);
    return this.declarationPart = declarationPart.join('\n').trim();
  };

  CSSS.prototype.doesLineBeginsWithAttribute = function(line) {
    var regex, regexString;

    if (this.pattern.doesLineBeginWithAttribute) {
      regex = this.pattern.doesLineBeginWithAttribute;
    } else {
      regexString = this.attributesTypes.split('-').join('\\-');
      regexString = "^\\s+(\\-moz\\-|\\-ms\\-|mso\\-|\\-khtml\\-|\\-webkit\\-|\\-o\\-){0,1}(" + regexString + "){1}";
      regex = this.pattern.doesLineBeginWithAttribute = new RegExp(regexString);
    }
    return regex.test(line);
  };

  CSSS.prototype.parse = function(s) {
    var line, lines, matches, styletext;

    if (s) {
      this.original = s;
    }
    if (this.original) {
      this.original = this.original.replace(this.pattern.comments(), '\n').replace(/\n{3,}/g, '\n\n');
      if (this.seperateDeclarations) {
        this.seperateDeclarationAndStyle();
      }
      this.processDeclaration();
      styletext = '\n' + this.cleanup(this.styletext);
      lines = (function() {
        var _i, _len, _ref, _results;

        _ref = styletext.split('\n');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          if (this.pattern.isMediaQuery.test(line)) {
            matches = line.match(this.pattern.isMediaQuery);
            if (matches != null ? matches[2] : void 0) {
              _results.push(line = "" + matches[1] + " " + (this.operateInline(matches[2])));
            } else {
              _results.push(void 0);
            }
          } else if (this.doesLineBeginsWithAttribute(line)) {
            _results.push(line = this.parseAttributeLine(line, {
              indent: '  ',
              escape: true
            }));
          } else {
            line = this.parseInlineArguments(line);
            line = line.replace(/^(\s+)(\@[a-zA-Z]+\(.*\))/g, '\n  $2');
            line = line.replace(/^(\s*)([a-zA-Z\.\#\&\>\:]+((?!\:\s).)*)$/, "\n@add '$2', '$1', ");
            _results.push(line = line.replace(/\n(\s*)([a-zA-Z\.\#\&\>]+((?!\:\s).)*)(\s*)$/, "\n@add '$2', '$1', $4"));
          }
        }
        return _results;
      }).call(this);
      styletext = lines.join('\n').replace(/\n+/g, "\n");
      styletext = styletext.replace(/(\n@add\s.+?)(\,\s[\n])(@add\s)/g, '$1\n$3');
      this.source = this.declarationPart + '\n\n' + styletext.trim();
      this.source = this.source.trim();
      return this.compile();
    }
  };

  CSSS.prototype.parseAttributeLine = function(line, options) {
    var attr, indent, m, value, _ref;

    if (options == null) {
      options = {};
    }
    indent = options.indent;
    if (indent == null) {
      indent = line.match(/^(\s+)/)[1] || '';
    }
    m = line.match(/^(\s+)([a-zA-Z\-]+)(\:|\s){1}\s*(.+)$/);
    value = m != null ? (_ref = m[4]) != null ? _ref.trim() : void 0 : void 0;
    attr = m != null ? m[2] : void 0;
    if (value) {
      if (!/^\'.*\'$/.test(value)) {
        value = this.operateInline(value, options);
        value = value.replace(/\+\'\)$/, ')');
        value = this.parseInlineArguments(value);
      }
      return "" + indent + "'" + attr + "': " + value;
    } else {
      return line.replace(/^(\s+)([a-zA-Z\-]+)/, "" + indent + "'$2':");
    }
  };

  CSSS.prototype.parseInlineArguments = function(line) {
    var argument, method, methodsFound, parts, value, _i, _len;

    methodsFound = line.match(/@[a-zA-Z\_]+\(.+\)/g);
    if (methodsFound) {
      for (_i = 0, _len = methodsFound.length; _i < _len; _i++) {
        method = methodsFound[_i];
        parts = method.match(/^(@[a-zA-Z\_]+)\(([a-zA-Z0-9\%]+)\)/);
        if (parts != null ? parts[2] : void 0) {
          value = parts[2];
          argument = this.pattern.isNotParsableValue.test(value) ? value : this.operateInline(value, {
            enclose: true
          });
          line = line.split(parts[0]).join(parts[1] + ("(" + argument + ")"));
        }
      }
    }
    return line;
  };

  CSSS.prototype.compile = function() {
    var e, pre;

    this.declarationPart = null;
    pre = '';
    try {
      this.javascript = CoffeeScript.compile(pre + this.source);
      return this.coffeescript = pre + '\n\n  ' + this.source.split('\n').join('\n  ') + '\n\n';
    } catch (_error) {
      e = _error;
      this.error(e);
      return this.source;
    }
  };

  CSSS.prototype["eval"] = function(context) {
    if (this.context == null) {
      this.createContext();
    }
    if (this.context) {
      if (window) {
        CoffeeScript.__csss_context = this.context;
      }
      this.coffeescript = "doc = CoffeeScript.__csss_context || this\nrgba = -> 'rgba('+Array.prototype.slice.call(arguments).join(\", \")+')'\nrgb  = -> 'rgb('+Array.prototype.slice.call(arguments).join(\", \")+')'\ndoc.init()\ndoc.eval = ->\n  " + this.coffeescript + "\ndoc.eval()\ndoc";
      return this.evaluated = CoffeeScript["eval"](this.coffeescript);
    } else {
      return CoffeeScript["eval"](this.coffeescript, {
        sandbox: this.context
      });
    }
  };

  CSSS.prototype.cleanup = function(s) {
    s = "\n" + s.replace(/\n+/g, "\n");
    s = s.replace(/\;[^\S\n]*/g, ''.replace(/\t/g, '  '));
    return s.trim();
  };

  CSSS.prototype.error = function(e) {
    var _ref;

    if (e != null) {
      this._error = e;
    }
    return ((_ref = this._error) != null ? _ref.message : void 0) || this._error || null;
  };

  CSSS.prototype.css = function(cssString, o) {
    var before, i, insideParts, isReference, level, levelBefore, levels, mediaQuery, parts, s, section, selector, selectorBefore, selectorString, values, _i, _j, _len, _objectToCSS, _ref, _ref1, _ref2, _ref3, _s;

    if (cssString == null) {
      cssString = '';
    }
    if (o == null) {
      o = null;
    }
    levels = {};
    levelBefore = null;
    selectorBefore = '';
    _objectToCSS = function(o) {
      var attribute, escape, parts;

      parts = (function() {
        var _results;

        _results = [];
        for (attribute in o) {
          escape = attribute === 'content' ? "'" : '';
          _results.push("" + attribute + ": " + escape + o[attribute] + escape + ";");
        }
        return _results;
      })();
      if (parts.length > 0) {
        return '{ ' + parts.join('\n') + ' }';
      } else {
        return null;
      }
    };
    mediaQuery = null;
    _ref1 = (_ref = this.evaluated) != null ? _ref._levels : void 0;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      section = _ref1[_i];
      if (section[0] === '@media') {
        if (mediaQuery) {
          cssString += ' } ';
        }
        cssString += "\n@media " + section[1] + " {";
        mediaQuery = section[1];
      } else {
        selector = selectorString = section[0];
        level = Math.floor(section[1].length / 2);
        values = _objectToCSS(section[2]);
        isReference = selectorString[0] === '&';
        if (section.length > 2) {
          for (i = _j = 3, _ref2 = section.length; 3 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 3 <= _ref2 ? ++_j : --_j) {
            DocumentStyle.prototype._extend(section[2], section[i]);
          }
        }
        if (level < levelBefore && isReference && (levels != null ? levels[level - 1] : void 0)) {
          selectorString = levels[level - 1].trim() + selectorString.trim().substring(1);
        } else if (level >= levelBefore) {
          if (isReference) {
            parts = (function() {
              var _k, _len1, _ref3, _results;

              _ref3 = selectorString.substring(1).split(',');
              _results = [];
              for (_k = 0, _len1 = _ref3.length; _k < _len1; _k++) {
                s = _ref3[_k];
                if (/^[a-z]+/.test(s)) {
                  s = ' ' + s;
                }
                insideParts = (function() {
                  var _l, _len2, _ref4, _results1;

                  _ref4 = levels[level - 1].trim().split(',');
                  _results1 = [];
                  for (_l = 0, _len2 = _ref4.length; _l < _len2; _l++) {
                    _s = _ref4[_l];
                    if (_s != null ? _s.trim() : void 0) {
                      _results1.push(_s.trim() + s.replace(/\s([^a-zA-Z])/g, '$1').replace(/\s([a-zA-Z]+.+)/g, ' $1'));
                    } else {
                      _results1.push(void 0);
                    }
                  }
                  return _results1;
                })();
                _results.push(insideParts.join(', ').replace(/\,\s$/, ''));
              }
              return _results;
            })();
            selectorString = parts.join(', ').replace(/\,\s$/, '');
          } else {
            before = (_ref3 = levels[level - 1]) != null ? _ref3.trim() : void 0;
            selectorString = selectorString.trim();
            if (!/^[\.\#\:]{1}/.test(selectorString.trim())) {
              selectorString = ' ' + selectorString;
            }
            selectorString = (before || '') + ' ' + selectorString.trim();
          }
        }
        if (values) {
          cssString += "\n" + selectorString + " " + (_objectToCSS(section[2]));
        }
        if (level !== levelBefore) {
          levelBefore = level;
          selectorBefore = selectorString;
        }
        levels[level] = selectorString;
      }
    }
    if (mediaQuery) {
      cssString += " } ";
    }
    return cssString;
  };

  return CSSS;

})();

if (window) {
  if ((_ref = window.CSSS) == null) {
    window.CSSS = CSSS;
  }
} else {
  exports = CSSS;
}
